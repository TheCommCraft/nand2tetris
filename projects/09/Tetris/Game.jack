class Game {
    field Board board;
    field int score;
    field Piece nextPiece;
    field Random random;
    field MemArena arena;
    constructor Game new(int randomSeed) {
        // slots
        // 202: emptied for clearRows
        // 235: random
        // 239: piece a
        // 243: piece b
        // 247: piece pos array
        // 255: board
        // 256: board data
        var int i;
        let arena = MemArena.make(256 + Board.getSize() + 32);
        let board = Board.new(arena);
        let i = 0;
        while (i < 16) {
            do board.setAtPos(10, i, 1);
            do board.setAtPos(21, i, 1);
            let i = i + 1;
        }
        let score = 0;
        do printScore();
        let random = Random.init(randomSeed, arena);
        let nextPiece = newPiece();
        do Output.moveCursor(8, 6);
        do Output.printString("NEXT:");
        do printPiece(nextPiece, true);
        return this;
    }

    method void dispose() {
        do nextPiece.dispose();
        do board.dispose();
        do Game.disposeSafely(this);
        return;
    }

    method Board getBoard() {
        return board;
    }

    method boolean testCollision(Piece p) {
        var Array a;
        var int i, aLength, pX, pY;
        let aLength = p.getTileCount() * 2;
        let pX = p.getX();
        let pY = p.getY();
        let a = p.getTiles(arena);
        let i = 0;
        while (i < aLength) {
            if (a[i + 1] + pY > (Board.getHeight() - 1)) {
                do Game.disposeSafely(a);
                return true;
            }
            if (~(board.getAtPos(a[i] + pX, a[i + 1] + pY) = 0)) {
                do board.getAtPos(a[i] + pX, a[i + 1] + pY);
                do Game.disposeSafely(a);
                return true;
            }
            let i = i + 2;
        }
        do Game.disposeSafely(a);
        return false;
    }

    method Array getNewPiecePlace() {
        if (nextPiece = 239) {
            return 243;
        }
        return 239;
    }

    method Piece newPiece() {
        var Piece p;
        let p = Piece.fromRandom(random, arena.getAt(getNewPiecePlace()));
        do p.setX(4);
        do p.setY(7);
        return p;
    }

    method void printScore() {
        do Output.moveCursor(2, 3);
        do Output.printString("SCORE: ");
        do Output.printInt(score);
        return;
    }

    method void printPiece(Piece p, boolean color) {
        var Array a;
        var int i, aLength, pX, pY, pType;
        let aLength = p.getTileCount() * 2;
        let pX = p.getX();
        let pY = p.getY();
        let a = p.getTiles(arena);
        let pType = p.getType() + 65;
        if (~color) {
            let pType = 0;
        }
        let i = 0;
        while (i < aLength) {
            do board.setAtPos(a[i] + pX, a[i + 1] + pY, pType);
            let i = i + 2;
        }
        do Game.disposeSafely(a);
        return;
    }

    method void checkRows(int startRow, int amount) {
        var int x, y, offset, tile;
        var boolean rowFull;
        var Array emptied;
        let emptied = arena.getAt(202);
        let y = 0;
        while (y < Board.getHeight()) {
            let emptied[y] = false;
            let y = y + 1;
        }
        let y = startRow;
        while (y < (startRow + amount)) {
            let rowFull = true;
            let x = 11;
            while ((x < 21) & rowFull) {
                let rowFull = board.getAtPos(x, y) > 0;
                let x = x + 1;
            }
            if (rowFull) {
                let emptied[y] = true;
                let x = 11;
                while (x < 21) {
                    do board.setAtPos(x, y, 0);
                    let x = x + 1;
                }
            }
            let y = y + 1;
        }
        let y = Board.getHeight() - 1;
        let offset = 0;
        while (y > 0) {
            if (emptied[y]) {
                let offset = offset + 1;
            } else {
                if (offset > 0) {
                    let x = 11;
                    while (x < 21) {
                        let tile = board.getAtPos(x, y);
                        do board.setAtPos(x, y, 0);
                        do board.setAtPos(x, y + offset, tile);
                        let x = x + 1;
                    }
                }
            }
            let y = y - 1;
        }
        if (offset = 1) {
            let score = score + 100;
            do printScore();
        }
        if (offset = 2) {
            let score = score + 300;
            do printScore();
        }
        if (offset = 3) {
            let score = score + 500;
            do printScore();
        }
        if (offset > 3) {
            let score = score + 800;
            do printScore();
        }
        do Game.disposeSafely(emptied);
        return;
    }

    method boolean moveRotated(Piece piece) {
        if (~testCollision(piece)) {
            do printPiece(piece, true);
            return false;
        }
        do piece.setX(piece.getX() + 1);
        if (~testCollision(piece)) {
            do printPiece(piece, true);
            return false;
        }
        do piece.setX(piece.getX() - 2);
        if (~testCollision(piece)) {
            do printPiece(piece, true);
            return false;
        }
        do piece.setX(piece.getX() + 1);
        do piece.setY(piece.getY() + 1);
        if (~testCollision(piece)) {
            do printPiece(piece, true);
            return false;
        }
        do piece.setY(piece.getY() - 2);
        if (~testCollision(piece)) {
            do printPiece(piece, true);
            return false;
        }
        do piece.setY(piece.getY() + 1);
        return true;
    }

    method void mainLoop() {
        var Piece piece;
        var int i, key, dropCountdown, maxDropCountdown, currentRot;
        var boolean pieceDone, stopped, continueFall;
        let continueFall = false;
        let i = 0;
        let maxDropCountdown = 5;
        let stopped = false;
        while (~stopped) {
            let dropCountdown = maxDropCountdown;
            let pieceDone = false;
            do printPiece(nextPiece, false);
            let piece = nextPiece;
            let nextPiece = newPiece();
            do printPiece(nextPiece, true);
            do piece.setX(16);
            do piece.setY(0);
            do printPiece(piece, true);
            while (~pieceDone & ~stopped) {
                let i = i + 1;
                do Sys.wait(100);
                let key = Keyboard.keyPressed();
                if (key = 140) { // escape
                    let stopped = true;
                }
                if (key = 97) { // a
                    do printPiece(piece, false);
                    do piece.setX(piece.getX() - 1);
                    if (testCollision(piece)) {
                        do piece.setX(piece.getX() + 1);
                    }
                    do printPiece(piece, true);
                }
                if (key = 100) { // d
                    do printPiece(piece, false);
                    do piece.setX(piece.getX() + 1);
                    if (testCollision(piece)) {
                        do piece.setX(piece.getX() - 1);
                    }
                    do printPiece(piece, true);
                }
                if (key = 115) { // s
                    let dropCountdown = 1;
                }
                if (key = 130) { // L-arrow
                    do printPiece(piece, false);
                    let currentRot = piece.getRot();
                    if (currentRot = 3) {
                        do piece.setRot(0);
                    } else {
                        do piece.setRot(piece.getRot() + 1);
                    }
                    if (moveRotated(piece)) {
                        do piece.setRot(currentRot);
                        do printPiece(piece, true);
                    }
                }
                if (key = 132) { // R-arrow
                    do printPiece(piece, false);
                    let currentRot = piece.getRot();
                    if (currentRot = 0) {
                        do piece.setRot(3);
                    } else {
                        do piece.setRot(piece.getRot() - 1);
                    }
                    if (moveRotated(piece)) {
                        do piece.setRot(currentRot);
                        do printPiece(piece, true);
                    }
                }
                if (key = 133) { // D-arrow
                    do printPiece(piece, false);
                    let continueFall = true;
                    let dropCountdown = maxDropCountdown;
                    while (continueFall) {
                        do piece.setY(piece.getY() + 1);
                        if (testCollision(piece)) {
                            let score = score + 8;
                            do printScore();
                            let pieceDone = true;
                            do piece.setY(piece.getY() - 1);
                            do printPiece(piece, true);
                            do checkRows(0, Board.getHeight());
                            let continueFall = false;
                            do Sys.wait(200);
                        }
                    }
                }
                do random.introduceState(key);
                let dropCountdown = dropCountdown - 1;
                if (dropCountdown < 1) {
                    do printPiece(piece, false);
                    let dropCountdown = maxDropCountdown;
                    do piece.setY(piece.getY() + 1);
                    if (testCollision(piece)) {
                        let score = score + 4;
                        do printScore();
                        let pieceDone = true;
                        do piece.setY(piece.getY() - 1);
                        do printPiece(piece, true);
                        do checkRows(0, Board.getHeight());
                    } else {
                        do printPiece(piece, true);
                    }
                }
            }
            do piece.dispose();
        }
        do random.dispose();
        return;
    }

    function void disposeSafely(int i) {
        var int l;
        var int p;
        var int counter;
        // let l = Memory.peek(i - 1);
        // let p = i;
        // let counter = l;
        // while (counter > 0) {
        //     let counter = counter - 1;
        //     do Memory.poke(p, 0);
        //     let p = p + 1;
        // }
        // do Memory.deAlloc(i);
        return;
    }
}