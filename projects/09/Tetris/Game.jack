class Game {
    field Board board;
    constructor Game new() {
        var int i;
        let board = Board.new();
        let i = 0;
        while (i < 16) {
            do board.setAtPos(10, i, 1);
            do board.setAtPos(21, i, 1);
            let i = i + 1;
        }
        return this;
    }

    method void dispose() {
        do board.dispose();
        do Game.disposeSafely(this);
        return;
    }

    method Board getBoard() {
        return board;
    }

    method boolean testCollision(Piece p) {
        var Array a;
        var int i, aLength, pX, pY;
        let aLength = p.getTileCount() * 2;
        let pX = p.getX();
        let pY = p.getY();
        let a = p.getTiles();
        let i = 0;
        while (i < aLength) {
            if (a[i + 1] + pY > (Board.getHeight() - 1)) {
                do Game.disposeSafely(a);
                return true;
            }
            if (~(board.getAtPos(a[i] + pX, a[i + 1] + pY) = 0)) {
                do board.getAtPos(a[i] + pX, a[i + 1] + pY);
                do Game.disposeSafely(a);
                return true;
            }
            let i = i + 2;
        }
        do Game.disposeSafely(a);
        return false;
    }

    method void printPiece(Piece p, boolean color) {
        var Array a;
        var int i, aLength, pX, pY, pType;
        let aLength = p.getTileCount() * 2;
        let pX = p.getX();
        let pY = p.getY();
        let a = p.getTiles();
        let pType = p.getType() + 65;
        if (~color) {
            let pType = 0;
        }
        let i = 0;
        while (i < aLength) {
            do board.setAtPos(a[i] + pX, a[i + 1] + pY, pType);
            let i = i + 2;
        }
        do Game.disposeSafely(a);
        return;
    }

    method void checkRows(int startRow, int amount) {
        var int x, y, offset, tile;
        var boolean rowFull;
        var Array emptied;
        let emptied = Array.new(Board.getHeight());
        let y = startRow;
        while (y < (startRow + amount)) {
            let rowFull = true;
            let x = 11;
            while ((x < 21) & rowFull) {
                let rowFull = board.getAtPos(x, y) > 0;
                let x = x + 1;
            }
            if (rowFull) {
                let emptied[y] = true;
                let x = 11;
                while (x < 21) {
                    do board.setAtPos(x, y, 0);
                    let x = x + 1;
                }
            }
            let y = y + 1;
        }
        let y = Board.getHeight() - 1;
        let offset = 0;
        while (y > 0) {
            if (emptied[y]) {
                let offset = offset + 1;
            } else {
                if (offset > 0) {
                    let x = 11;
                    while (x < 21) {
                        let tile = board.getAtPos(x, y);
                        do board.setAtPos(x, y, 0);
                        do board.setAtPos(x, y + offset, tile);
                        let x = x + 1;
                    }
                }
            }
            let y = y - 1;
        }
        do Game.disposeSafely(emptied);
        return;
    }

    method boolean moveRotated(Piece piece) {
        if (~testCollision(piece)) {
            do printPiece(piece, true);
            return false;
        }
        do piece.setX(piece.getX() + 1);
        if (~testCollision(piece)) {
            do printPiece(piece, true);
            return false;
        }
        do piece.setX(piece.getX() - 2);
        if (~testCollision(piece)) {
            do printPiece(piece, true);
            return false;
        }
        do piece.setX(piece.getX() - 1);
        do piece.setY(piece.getY() + 1);
        if (~testCollision(piece)) {
            do printPiece(piece, true);
            return false;
        }
        do piece.setY(piece.getY() - 2);
        if (~testCollision(piece)) {
            do printPiece(piece, true);
            return false;
        }
        do piece.setY(piece.getY() + 1);
        return true;
    }

    method void mainLoop(int randomSeed) {
        var Random random;
        var Piece piece;
        var int i, key, dropCountdown, maxDropCountdown, currentRot;
        var boolean pieceDone, stopped;
        let i = 0;
        let maxDropCountdown = 5;
        let stopped = false;
        let random = Random.init(randomSeed);
        while (~stopped) {
            let dropCountdown = maxDropCountdown;
            let pieceDone = false;
            let piece = Piece.fromRandom(random);
            do piece.setX(16);
            do piece.setY(0);
            do printPiece(piece, true);
            while (~pieceDone & ~stopped) {
                let i = i + 1;
                do Sys.wait(100);
                let key = Keyboard.keyPressed();
                if (key = 140) { // escape
                    let stopped = true;
                }
                if (key = 97) { // a
                    do printPiece(piece, false);
                    do piece.setX(piece.getX() - 1);
                    if (testCollision(piece)) {
                        do piece.setX(piece.getX() + 1);
                    }
                    do printPiece(piece, true);
                }
                if (key = 100) { // d
                    do printPiece(piece, false);
                    do piece.setX(piece.getX() + 1);
                    if (testCollision(piece)) {
                        do piece.setX(piece.getX() - 1);
                    }
                    do printPiece(piece, true);
                }
                if (key = 115) { // s
                    let dropCountdown = 1;
                }
                if (key = 130) { // L-arrow
                    do printPiece(piece, false);
                    let currentRot = piece.getRot();
                    if (currentRot = 3) {
                        do piece.setRot(0);
                    } else {
                        do piece.setRot(piece.getRot() + 1);
                    }
                    if (moveRotated(piece)) {
                        do piece.setRot(currentRot);
                        do printPiece(piece, true);
                    }
                }
                if (key = 132) { // R-arrow
                    do printPiece(piece, false);
                    let currentRot = piece.getRot();
                    if (currentRot = 0) {
                        do piece.setRot(3);
                    } else {
                        do piece.setRot(piece.getRot() - 1);
                    }
                    if (moveRotated(piece)) {
                        do piece.setRot(currentRot);
                        do printPiece(piece, true);
                    }
                }
                do random.introduceState(key);
                let dropCountdown = dropCountdown - 1;
                if (dropCountdown < 1) {
                    do printPiece(piece, false);
                    let dropCountdown = maxDropCountdown;
                    do piece.setY(piece.getY() + 1);
                    if (testCollision(piece)) {
                        let pieceDone = true;
                        do piece.setY(piece.getY() - 1);
                        do printPiece(piece, true);
                        do Sys.wait(1000);
                        do checkRows(0, Board.getHeight());
                    } else {
                        do printPiece(piece, true);
                    }
                }
            }
            do piece.dispose();
        }
        do random.dispose();
        return;
    }

    function void disposeSafely(int i) {
        var int l;
        var int p;
        var int counter;
        let l = Memory.peek(i - 1);
        let p = i;
        let counter = l;
        while (counter > 0) {
            let counter = counter - 1;
            do Memory.poke(p, 0);
            let p = p + 1;
        }
        do Memory.deAlloc(i);
        return;
    }
}